{"version":3,"sources":["webpack:///./u2f/error.js","webpack:///./u2f/util.js","webpack:////var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/u2f.js","webpack:///./u2f/register.js","webpack:///./pages/profiles/two_factor_auths/index.js"],"names":["U2FError","errorCode","u2fFlowType","_classCallCheck","this","message","bind","httpsDisabled","window","location","protocol","u2f","ErrorCodes","BAD_REQUEST","DEVICE_INELIGIBLE","isOpera","userAgent","indexOf","canInjectU2fApi","isSupportedChrome","isChrome","match","parseInt","getChromeVersion","isSupportedOpera","getOperaVersion","isMobile","test","importU2FLibrary","Promise","resolve","navigator","gon","test_env","then","__webpack_require__","t","reject","d","__webpack_exports__","$","js_api_version","EXTENSION_ID","MessageTypes","U2F_REGISTER_REQUEST","U2F_REGISTER_RESPONSE","U2F_SIGN_REQUEST","U2F_SIGN_RESPONSE","U2F_GET_API_VERSION_REQUEST","U2F_GET_API_VERSION_RESPONSE","OK","OTHER_ERROR","CONFIGURATION_UNSUPPORTED","TIMEOUT","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","signRequests","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","inArray","platform","port","connect","includeTlsChannelId","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","port_","formatSignRequest_","appId","challenge","registeredKeys","timeoutSeconds","reqId","undefined","i","length","version","keyHandle","requestId","formatRegisterRequest_","registerRequests","prototype","postMessage","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","data","console","error","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","JSON","stringify","document","getPortType","onRequestUpdate_","messageObject","parse","responseObject","hasOwnProperty","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","ready","port1","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","shift","push","responseHandler_","response","cb","sign","opt_timeoutSeconds","getApiVersion","log","sendSignRequest","req","register","sendRegisterRequest","apiVersion","U2FRegister","container","u2fParams","u2fUtils","renderNotSupported","renderRegistered","renderError","renderInProgress","renderSetup","renderTemplate","app_id","register_requests","sign_requests","templates","notSupported","setup","inProgress","registered","_this","Object","util","utils","catch","_this2","u2f_error","params","templateString","jquery_default","html","template","underscore_default","a","find","on","error_message","error_code","deviceResponse","val","twoFactorNode","querySelector","dataset","twoFactorSkippable","button","two_factor_skip_url","flashAlert","insertAdjacentHTML","u2f_register"],"mappings":"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","file":"pages.profiles.two_factor_auths.a56d32f5.chunk.js","sourcesContent":["export default class U2FError {\n  constructor(errorCode, u2fFlowType) {\n    this.errorCode = errorCode;\n    this.message = this.message.bind(this);\n    this.httpsDisabled = window.location.protocol !== 'https:';\n    this.u2fFlowType = u2fFlowType;\n  }\n\n  message() {\n    if (this.errorCode === window.u2f.ErrorCodes.BAD_REQUEST && this.httpsDisabled) {\n      return 'U2F only works with HTTPS-enabled websites. Contact your administrator for more details.';\n    } else if (this.errorCode === window.u2f.ErrorCodes.DEVICE_INELIGIBLE) {\n      if (this.u2fFlowType === 'authenticate') {\n        return 'This device has not been registered with us.';\n      }\n      if (this.u2fFlowType === 'register') {\n        return 'This device has already been registered with us.';\n      }\n    }\n    return 'There was a problem communicating with your device.';\n  }\n}\n","function isOpera(userAgent) {\n  return userAgent.indexOf('Opera') >= 0 || userAgent.indexOf('OPR') >= 0;\n}\n\nfunction getOperaVersion(userAgent) {\n  const match = userAgent.match(/OPR[^0-9]*([0-9]+)[^0-9]+/);\n  return match ? parseInt(match[1], 10) : false;\n}\n\nfunction isChrome(userAgent) {\n  return userAgent.indexOf('Chrom') >= 0 && !isOpera(userAgent);\n}\n\nfunction getChromeVersion(userAgent) {\n  const match = userAgent.match(/Chrom(?:e|ium)\\/([0-9]+)\\./);\n  return match ? parseInt(match[1], 10) : false;\n}\n\nexport function canInjectU2fApi(userAgent) {\n  const isSupportedChrome = isChrome(userAgent) && getChromeVersion(userAgent) >= 41;\n  const isSupportedOpera = isOpera(userAgent) && getOperaVersion(userAgent) >= 40;\n  const isMobile = (\n    userAgent.indexOf('droid') >= 0 ||\n    userAgent.indexOf('CriOS') >= 0 ||\n    /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent)\n  );\n  return (isSupportedChrome || isSupportedOpera) && !isMobile;\n}\n\nexport default function importU2FLibrary() {\n  if (window.u2f) {\n    return Promise.resolve(window.u2f);\n  }\n\n  const userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n  if (canInjectU2fApi(userAgent) || (gon && gon.test_env)) {\n    return import(/* webpackMode: \"eager\" */ 'vendor/u2f').then(() => window.u2f);\n  }\n\n  return Promise.reject();\n}\n","//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n\n/**\n * Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\n/**\n * FIDO U2F Javascript API Version\n * @number\n */\nvar js_api_version;\n\n/**\n * The U2F extension id\n * @const {string}\n */\n// The Chrome packaged app extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the package Chrome app and does not require installing the U2F Chrome extension.\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n// The U2F Chrome extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the U2F Chrome extension to authenticate.\n// u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n};\n\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n};\n\n\n/**\n * A message for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   appId: ?string,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.U2fRequest;\n\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.U2fResponse;\n\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n */\nu2f.Transport;\n\n\n/**\n * Data object for a single sign request.\n * @typedef {Array<u2f.Transport>}\n */\nu2f.Transports;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string\n * }}\n */\nu2f.RegisterRequest;\n\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: Transports,\n *   appId: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n/**\n * Data object for a registered key.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: ?Transports,\n *   appId: ?string\n * }}\n */\nu2f.RegisteredKey;\n\n\n/**\n * Data object for a get API register response.\n * @typedef {{\n *   js_api_version: number\n * }}\n */\nu2f.GetJsApiVersionResponse;\n\n\n//Low level MessagePort API support\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n        // The actual message here does not matter, but we need to get a reply\n        // for the callback to run. Thus, send an empty signature request\n        // in order to get a failure response.\n        var msg = {\n            type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n            signRequests: []\n        };\n        chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n            if (!chrome.runtime.lastError) {\n                // We are on a whitelisted origin and can talk directly\n                // with the extension.\n                u2f.getChromeRuntimePort_(callback);\n            } else {\n                // chrome.runtime was available, but we couldn't message\n                // the extension directly, use iframe\n                u2f.getIframePort_(callback);\n            }\n        });\n    } else if (u2f.isAndroidChrome_()) {\n        u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n        u2f.getIosPort_(callback);\n    } else {\n        // chrome.runtime was not available at all, which is normal\n        // when this origin doesn't have access to any extensions.\n        u2f.getIframePort_(callback);\n    }\n};\n\n/**\n * Detect chrome running on android based on the browser's useragent.\n * @private\n */\nu2f.isAndroidChrome_ = function() {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 &&\n        userAgent.indexOf('Android') != -1;\n};\n\n/**\n * Detect chrome running on iOS based on the browser's platform.\n * @private\n */\nu2f.isIosChrome_ = function() {\n    return $.inArray(navigator.platform, [\"iPhone\", \"iPad\", \"iPod\"]) > -1;\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect.\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n        {'includeTlsChannelId': true});\n    setTimeout(function() {\n        callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the Authenticator app.\n * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n * @private\n */\nu2f.getAuthenticatorPort_ = function(callback) {\n    setTimeout(function() {\n        callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the iOS client app.\n * @param {function(u2f.WrappedIosPort_)} callback\n * @private\n */\nu2f.getIosPort_ = function(callback) {\n    setTimeout(function() {\n        callback(new u2f.WrappedIosPort_());\n    }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n    this.port_ = port;\n};\n\n/**\n * Format and return a sign request compliant with the JS API version supported by the extension.\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatSignRequest_ =\n    function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n        if (js_api_version === undefined || js_api_version < 1.1) {\n            // Adapt request to the 1.0 JS API\n            var signRequests = [];\n            for (var i = 0; i < registeredKeys.length; i++) {\n                signRequests[i] = {\n                    version: registeredKeys[i].version,\n                    challenge: challenge,\n                    keyHandle: registeredKeys[i].keyHandle,\n                    appId: appId\n                };\n            }\n            return {\n                type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n                signRequests: signRequests,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        }\n        // JS 1.1 API\n        return {\n            type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n            appId: appId,\n            challenge: challenge,\n            registeredKeys: registeredKeys,\n            timeoutSeconds: timeoutSeconds,\n            requestId: reqId\n        };\n    };\n\n/**\n * Format and return a register request compliant with the JS API version supported by the extension..\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {Array<u2f.RegisterRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatRegisterRequest_ =\n    function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n        if (js_api_version === undefined || js_api_version < 1.1) {\n            // Adapt request to the 1.0 JS API\n            for (var i = 0; i < registerRequests.length; i++) {\n                registerRequests[i].appId = appId;\n            }\n            var signRequests = [];\n            for (var i = 0; i < registeredKeys.length; i++) {\n                signRequests[i] = {\n                    version: registeredKeys[i].version,\n                    challenge: registerRequests[0],\n                    keyHandle: registeredKeys[i].keyHandle,\n                    appId: appId\n                };\n            }\n            return {\n                type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n                signRequests: signRequests,\n                registerRequests: registerRequests,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        }\n        // JS 1.1 API\n        return {\n            type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n            appId: appId,\n            registerRequests: registerRequests,\n            registeredKeys: registeredKeys,\n            timeoutSeconds: timeoutSeconds,\n            requestId: reqId\n        };\n    };\n\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n    this.port_.postMessage(message);\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n        var name = eventName.toLowerCase();\n        if (name == 'message' || name == 'onmessage') {\n            this.port_.onMessage.addListener(function(message) {\n                // Emulate a minimal MessageEvent object\n                handler({'data': message});\n            });\n        } else {\n            console.error('WrappedChromeRuntimePort only supports onMessage');\n        }\n    };\n\n/**\n * Wrap the Authenticator app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedAuthenticatorPort_ = function() {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n}\n\n/**\n * Launch the Authenticator intent.\n * @param {Object} message\n */\nu2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n    var intentUrl =\n        u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n        ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n        ';end';\n    document.location = intentUrl;\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n    return \"WrappedAuthenticatorPort_\";\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message') {\n        var self = this;\n        /* Register a callback to that executes when\n         * chrome injects the response. */\n        window.addEventListener(\n            'message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n        console.error('WrappedAuthenticatorPort only supports message');\n    }\n};\n\n/**\n * Callback invoked  when a response is received from the Authenticator.\n * @param function({data: Object}) callback\n * @param {Object} message message Object\n */\nu2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n    function(callback, message) {\n        var messageObject = JSON.parse(message.data);\n        var intentUrl = messageObject['intentURL'];\n\n        var errorCode = messageObject['errorCode'];\n        var responseObject = null;\n        if (messageObject.hasOwnProperty('data')) {\n            responseObject = /** @type {Object} */ (\n                JSON.parse(messageObject['data']));\n        }\n\n        callback({'data': responseObject});\n    };\n\n/**\n * Base URL for intents to Authenticator.\n * @const\n * @private\n */\nu2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n    'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n/**\n * Wrap the iOS client app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedIosPort_ = function() {};\n\n/**\n * Launch the iOS client app request\n * @param {Object} message\n */\nu2f.WrappedIosPort_.prototype.postMessage = function(message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedIosPort_.prototype.getPortType = function() {\n    return \"WrappedIosPort_\";\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name !== 'message') {\n        console.error('WrappedIosPort only supports message');\n    }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n\n    var channel = new MessageChannel();\n    var ready = function(message) {\n        if (message.data == 'ready') {\n            channel.port1.removeEventListener('message', ready);\n            callback(channel.port1);\n        } else {\n            console.error('First event on iframe port was not \"ready\"');\n        }\n    };\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n\n    iframe.addEventListener('load', function() {\n        // Deliver the port to the iframe and initialize\n        iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n};\n\n\n//High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n    if (u2f.port_) {\n        callback(u2f.port_);\n    } else {\n        if (u2f.waitingForPort_.length == 0) {\n            u2f.getMessagePort(function(port) {\n                u2f.port_ = port;\n                u2f.port_.addEventListener('message',\n                    /** @type {function(Event)} */ (u2f.responseHandler_));\n\n                // Careful, here be async callbacks. Maybe.\n                while (u2f.waitingForPort_.length)\n                    u2f.waitingForPort_.shift()(u2f.port_);\n            });\n        }\n        u2f.waitingForPort_.push(callback);\n    }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n        console.error('Unknown or missing requestId in response.');\n        return;\n    }\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the sign request.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n        // Send a message to get the extension to JS API version, then send the actual sign request.\n        u2f.getApiVersion(\n            function (response) {\n                js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n                console.log(\"Extension JS API Version: \", js_api_version);\n                u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n            });\n    } else {\n        // We know the JS API version. Send the actual sign request in the supported API version.\n        u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n        var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n        port.postMessage(req);\n    });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the register request.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n        // Send a message to get the extension to JS API version, then send the actual register request.\n        u2f.getApiVersion(\n            function (response) {\n                js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n                console.log(\"Extension JS API Version: \", js_api_version);\n                u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                    callback, opt_timeoutSeconds);\n            });\n    } else {\n        // We know the JS API version. Send the actual register request in the supported API version.\n        u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n            callback, opt_timeoutSeconds);\n    }\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n        var req = u2f.formatRegisterRequest_(\n            appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n        port.postMessage(req);\n    });\n};\n\n\n/**\n * Dispatches a message to the extension to find out the supported\n * JS API version.\n * If the user is on a mobile phone and is thus using Google Authenticator instead\n * of the Chrome extension, don't send the request and simply return 0.\n * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        // If we are using Android Google Authenticator or iOS client app,\n        // do not fire an intent to ask which JS API version to use.\n        if (port.getPortType) {\n            var apiVersion;\n            switch (port.getPortType()) {\n                case 'WrappedIosPort_':\n                case 'WrappedAuthenticatorPort_':\n                    apiVersion = 1.1;\n                    break;\n\n                default:\n                    apiVersion = 0;\n                    break;\n            }\n            callback({ 'js_api_version': apiVersion });\n            return;\n        }\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var req = {\n            type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n            timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n            requestId: reqId\n        };\n        port.postMessage(req);\n    });\n};\n\nwindow.u2f || (window.u2f = u2f);\n","import $ from 'jquery';\nimport _ from 'underscore';\nimport importU2FLibrary from './util';\nimport U2FError from './error';\n\n// Register U2F (universal 2nd factor) devices for users to authenticate with.\n//\n// State Flow #1: setup -> in_progress -> registered -> POST to server\n// State Flow #2: setup -> in_progress -> error -> setup\nexport default class U2FRegister {\n  constructor(container, u2fParams) {\n    this.u2fUtils = null;\n    this.container = container;\n    this.renderNotSupported = this.renderNotSupported.bind(this);\n    this.renderRegistered = this.renderRegistered.bind(this);\n    this.renderError = this.renderError.bind(this);\n    this.renderInProgress = this.renderInProgress.bind(this);\n    this.renderSetup = this.renderSetup.bind(this);\n    this.renderTemplate = this.renderTemplate.bind(this);\n    this.register = this.register.bind(this);\n    this.start = this.start.bind(this);\n    this.appId = u2fParams.app_id;\n    this.registerRequests = u2fParams.register_requests;\n    this.signRequests = u2fParams.sign_requests;\n\n    this.templates = {\n      notSupported: '#js-register-u2f-not-supported',\n      setup: '#js-register-u2f-setup',\n      inProgress: '#js-register-u2f-in-progress',\n      error: '#js-register-u2f-error',\n      registered: '#js-register-u2f-registered',\n    };\n  }\n\n  start() {\n    return importU2FLibrary()\n      .then((utils) => {\n        this.u2fUtils = utils;\n        this.renderSetup();\n      })\n      .catch(() => this.renderNotSupported());\n  }\n\n  register() {\n    return this.u2fUtils.register(this.appId, this.registerRequests, this.signRequests,\n      (response) => {\n        if (response.errorCode) {\n          const error = new U2FError(response.errorCode, 'register');\n          return this.renderError(error);\n        }\n        return this.renderRegistered(JSON.stringify(response));\n      }, 10);\n  }\n\n  renderTemplate(name, params) {\n    const templateString = $(this.templates[name]).html();\n    const template = _.template(templateString);\n    return this.container.html(template(params));\n  }\n\n  renderSetup() {\n    this.renderTemplate('setup');\n    return this.container.find('#js-setup-u2f-device').on('click', this.renderInProgress);\n  }\n\n  renderInProgress() {\n    this.renderTemplate('inProgress');\n    return this.register();\n  }\n\n  renderError(error) {\n    this.renderTemplate('error', {\n      error_message: error.message(),\n      error_code: error.errorCode,\n    });\n    return this.container.find('#js-u2f-try-again').on('click', this.renderSetup);\n  }\n\n  renderRegistered(deviceResponse) {\n    this.renderTemplate('registered');\n    // Prefer to do this instead of interpolating using Underscore templates\n    // because of JSON escaping issues.\n    return this.container.find('#js-device-response').val(deviceResponse);\n  }\n\n  renderNotSupported() {\n    return this.renderTemplate('notSupported');\n  }\n}\n","import $ from 'jquery';\nimport U2FRegister from '~/u2f/register';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const twoFactorNode = document.querySelector('.js-two-factor-auth');\n  const skippable = twoFactorNode.dataset.twoFactorSkippable === 'true';\n  if (skippable) {\n    const button = `<a class=\"btn btn-sm btn-warning float-right\" data-method=\"patch\" href=\"${twoFactorNode.dataset.two_factor_skip_url}\">Configure it later</a>`;\n    const flashAlert = document.querySelector('.flash-alert .container-fluid');\n    if (flashAlert) flashAlert.insertAdjacentHTML('beforeend', button);\n  }\n\n  const u2fRegister = new U2FRegister($('#js-register-u2f'), gon.u2f);\n  u2fRegister.start();\n});\n"],"sourceRoot":""}